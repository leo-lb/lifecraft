// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Draw from "./draw.bs.js";
import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../node_modules/bs-platform/lib/es6/array.js";
import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Global from "./global.bs.js";
import * as Caml_array from "../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Caml_int32 from "../node_modules/bs-platform/lib/es6/caml_int32.js";

var pointer = {
  contents: {
    x: 0,
    y: 0,
    i: 0,
    j: 0,
    inside: false,
    selecting: false
  }
};

var state_board = {
  contents: $$Array.make_matrix(Global.num_dot_x, Global.num_dot_y, /* Dead */0)
};

var state_previous = {
  contents: /* [] */0
};

function next(board) {
  var is_alive = function (coords) {
    var j = coords[1];
    var i = coords[0];
    if (i < 0 || i >= Global.num_dot_x || j < 0 || j >= Global.num_dot_y) {
      return 0;
    } else {
      var match = Caml_array.caml_array_get(Caml_array.caml_array_get(board, i), j);
      if (match) {
        return 1;
      } else {
        return 0;
      }
    }
  };
  var sum_neighbourg = function (x, y) {
    var coords = List.map((function (coords) {
            return /* tuple */[
                    x + coords[0] | 0,
                    y + coords[1] | 0
                  ];
          }), /* :: */[
          /* tuple */[
            -1,
            -1
          ],
          /* :: */[
            /* tuple */[
              -1,
              0
            ],
            /* :: */[
              /* tuple */[
                -1,
                1
              ],
              /* :: */[
                /* tuple */[
                  0,
                  -1
                ],
                /* :: */[
                  /* tuple */[
                    0,
                    1
                  ],
                  /* :: */[
                    /* tuple */[
                      1,
                      -1
                    ],
                    /* :: */[
                      /* tuple */[
                        1,
                        0
                      ],
                      /* :: */[
                        /* tuple */[
                          1,
                          1
                        ],
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]);
    var neighbourg = List.map(is_alive, coords);
    return List.fold_left((function (prim, prim$1) {
                  return prim + prim$1 | 0;
                }), 0, neighbourg);
  };
  var next_one = function (i, j, e) {
    var n = sum_neighbourg(i, j);
    if (e) {
      if (n === 3 || n === 2) {
        return /* Alive */1;
      } else {
        return /* Dead */0;
      }
    } else if (n !== 3) {
      return /* Dead */0;
    } else {
      return /* Alive */1;
    }
  };
  return Global.matrix_mapij(next_one, board);
}

function update_pointer(pointer) {
  var x = pointer.x - Caml_int32.mod_(pointer.x, Global.dot_w) | 0;
  var y = pointer.y - Caml_int32.mod_(pointer.y, Global.dot_h) | 0;
  var i = pointer.x;
  var j = pointer.y;
  var dist2 = Math.pow(x - (i + 0.5) * Global.dot_w, 2) + Math.pow(y - (j + 0.5) * Global.dot_h, 2);
  var inside = dist2 < Math.pow(Global.r, 2);
  return {
          x: pointer.x,
          y: pointer.y,
          i: Caml_int32.div(pointer.x, Global.dot_w),
          j: Caml_int32.div(pointer.y, Global.dot_h),
          inside: inside,
          selecting: pointer.selecting
        };
}

function flip(i, j, i2, j2, e) {
  if (i === i2 && j === j2) {
    if (e) {
      return /* Dead */0;
    } else {
      return /* Alive */1;
    }
  } else {
    return e;
  }
}

function update($$event) {
  var board;
  if (typeof $$event === "number") {
    switch ($$event) {
      case /* Nothing */0 :
          board = state_board.contents;
          break;
      case /* Next */1 :
          board = next(state_board.contents);
          break;
      case /* Previous */2 :
          board = List.hd(state_previous.contents);
          break;
      case /* Reset */3 :
          board = $$Array.make_matrix(Global.num_dot_x, Global.num_dot_y, /* Dead */0);
          break;
      
    }
  } else {
    switch ($$event.tag | 0) {
      case /* Click */0 :
          var j = $$event[1];
          var i = $$event[0];
          board = Global.matrix_mapij((function (param, param$1, param$2) {
                  return flip(i, j, param, param$1, param$2);
                }), state_board.contents);
          break;
      case /* ClickThenNext */1 :
          var j$1 = $$event[1];
          var i$1 = $$event[0];
          board = next(Global.matrix_mapij((function (param, param$1, param$2) {
                      return flip(i$1, j$1, param, param$1, param$2);
                    }), state_board.contents));
          break;
      case /* Select */2 :
          board = state_board.contents;
          break;
      
    }
  }
  var previous;
  var exit = 0;
  if (typeof $$event === "number") {
    switch ($$event) {
      case /* Next */1 :
          previous = List.append(/* :: */[
                state_board.contents,
                /* [] */0
              ], state_previous.contents);
          break;
      case /* Previous */2 :
          previous = List.tl(state_previous.contents);
          break;
      default:
        previous = state_previous.contents;
    }
  } else {
    switch ($$event.tag | 0) {
      case /* Click */0 :
      case /* ClickThenNext */1 :
          exit = 1;
          break;
      default:
        previous = state_previous.contents;
    }
  }
  if (exit === 1) {
    previous = List.append(/* :: */[
          state_board.contents,
          /* [] */0
        ], state_previous.contents);
  }
  state_previous.contents = previous;
  state_board.contents = board;
  pointer.contents = update_pointer(pointer.contents);
  Draw.draw(state_board.contents);
  return Draw.draw_selection(pointer.contents.x, pointer.contents.y);
}

function mousedown(x, y) {
  var init = pointer.contents;
  pointer.contents = {
    x: init.x,
    y: init.y,
    i: init.i,
    j: init.j,
    inside: init.inside,
    selecting: true
  };
  return update(/* ClickThenNext */Block.__(1, [
                Caml_int32.div(x, Global.dot_w),
                Caml_int32.div(y, Global.dot_h)
              ]));
}

function mouseup(param) {
  var init = pointer.contents;
  pointer.contents = {
    x: init.x,
    y: init.y,
    i: init.i,
    j: init.j,
    inside: init.inside,
    selecting: false
  };
  return /* () */0;
}

function mousemove(x, y) {
  var init = pointer.contents;
  pointer.contents = {
    x: x,
    y: y,
    i: init.i,
    j: init.j,
    inside: init.inside,
    selecting: init.selecting
  };
  return update(/* Select */Block.__(2, [
                Caml_int32.div(x, Global.dot_w),
                Caml_int32.div(y, Global.dot_h)
              ]));
}

function keydown(str) {
  var tmp;
  switch (str) {
    case "Escape" :
        tmp = /* Reset */3;
        break;
    case "LeftArrow" :
        tmp = /* Previous */2;
        break;
    case " " :
    case "RighArrow" :
        tmp = /* Next */1;
        break;
    default:
      tmp = /* Nothing */0;
  }
  return update(tmp);
}

function reset(param) {
  return update(/* Reset */3);
}

function previous(param) {
  return update(/* Previous */2);
}

function next$1(param) {
  return update(/* Next */1);
}

bind_mousemove(mousemove);

bind_mousedown(mousedown);

bind_mouseup(mouseup);

bind_keydown(keydown);

bind_next(next$1);

bind_previous(previous);

bind_reset(reset);

update(/* Click */Block.__(0, [
        10,
        5
      ]));

update(/* Click */Block.__(0, [
        10,
        6
      ]));

export {
  
}
/* state Not a pure module */
