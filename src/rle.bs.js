// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Bytes from "../node_modules/bs-platform/lib/es6/bytes.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Printf from "../node_modules/bs-platform/lib/es6/printf.js";
import * as $$String from "../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_bytes from "../node_modules/bs-platform/lib/es6/caml_bytes.js";
import * as Pervasives from "../node_modules/bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "../node_modules/bs-platform/lib/es6/caml_format.js";
import * as Caml_string from "../node_modules/bs-platform/lib/es6/caml_string.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";

function explode(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(s, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function implode(l) {
  var res = Caml_bytes.caml_create_bytes(List.length(l));
  var imp = function (_i, _param) {
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        res[i] = param[0];
        _param = param[1];
        _i = i + 1 | 0;
        continue ;
      } else {
        return res;
      }
    };
  };
  return Bytes.to_string(imp(0, l));
}

function parse_int(l) {
  var f = function (_acc, _l2) {
    while(true) {
      var l2 = _l2;
      var acc = _acc;
      if (l2) {
        var i = l2[0];
        if (i > 57 || i < 48) {
          return /* tuple */[
                  l2,
                  List.rev(acc)
                ];
        } else {
          _l2 = l2[1];
          _acc = /* :: */[
            i,
            acc
          ];
          continue ;
        }
      } else {
        return /* tuple */[
                l2,
                List.rev(acc)
              ];
      }
    };
  };
  var match = f(/* [] */0, l);
  return /* tuple */[
          match[0],
          Caml_format.caml_int_of_string(implode(match[1]))
        ];
}

function parse_header(_o, _l) {
  while(true) {
    var l = _l;
    var o = _o;
    var match = o.state;
    if (l) {
      var match$1 = l[0];
      if (match$1 !== 32) {
        if (match$1 !== 61) {
          switch (match) {
            case /* FindX */0 :
                if (l[0] === 120) {
                  _l = l[1];
                  _o = {
                    state: /* ParseX */1,
                    line: o.line,
                    grid: o.grid,
                    x: o.x,
                    y: o.y
                  };
                  continue ;
                }
                break;
            case /* ParseX */1 :
                if ((l[0] - 48 >>> 0) <= 9) {
                  var match$2 = parse_int(l);
                  _l = match$2[0];
                  _o = {
                    state: /* FindY */2,
                    line: o.line,
                    grid: o.grid,
                    x: match$2[1],
                    y: o.y
                  };
                  continue ;
                }
                break;
            case /* FindY */2 :
                if (l[0] === 121) {
                  _l = l[1];
                  _o = {
                    state: /* ParseY */3,
                    line: o.line,
                    grid: o.grid,
                    x: o.x,
                    y: o.y
                  };
                  continue ;
                }
                break;
            case /* ParseY */3 :
                if ((l[0] - 48 >>> 0) <= 9) {
                  var match$3 = parse_int(l);
                  return {
                          state: /* Reading */4,
                          line: o.line,
                          grid: o.grid,
                          x: o.x,
                          y: match$3[1]
                        };
                }
                break;
            case /* Reading */4 :
            case /* End */5 :
                break;
            
          }
        } else {
          _l = l[1];
          continue ;
        }
      } else {
        _l = l[1];
        continue ;
      }
    } else {
      throw [
            Caml_builtin_exceptions.failure,
            "Incomplete header"
          ];
    }
    throw [
          Caml_builtin_exceptions.invalid_argument,
          $$String.make(1, l[0])
        ];
  };
}

function parse_map(o, l) {
  var _n = 1;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var n = _n;
    if (l$1) {
      var c = l$1[0];
      if (c >= 48) {
        if (c !== 98) {
          if (c !== 111) {
            if (c >= 58) {
              throw [
                    Caml_builtin_exceptions.invalid_argument,
                    $$String.make(1, c)
                  ];
            }
            var match = parse_int(l$1);
            _l = match[0];
            _n = match[1];
            continue ;
          } else {
            return {
                    state: o.state,
                    line: Pervasives.$at(List.init(n, (function (param) {
                                return /* Alive */1;
                              })), o.line),
                    grid: o.grid,
                    x: o.x,
                    y: o.y
                  };
          }
        } else {
          return {
                  state: o.state,
                  line: Pervasives.$at(List.init(n, (function (param) {
                              return /* Dead */0;
                            })), o.line),
                  grid: o.grid,
                  x: o.x,
                  y: o.y
                };
        }
      } else if (c !== 33) {
        if (c !== 36) {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                $$String.make(1, c)
              ];
        }
        return {
                state: o.state,
                line: /* [] */0,
                grid: /* :: */[
                  o.line,
                  o.grid
                ],
                x: o.x,
                y: o.y
              };
      } else {
        return {
                state: /* End */5,
                line: o.line,
                grid: o.grid,
                x: o.x,
                y: o.y
              };
      }
    } else {
      return o;
    }
  };
}

function parse_line(o, s) {
  var l = explode(s);
  var c = List.hd(l);
  if (c === /* "#" */35) {
    return o;
  } else if (o.state === /* FindX */0) {
    return parse_header(o, l);
  } else {
    return parse_map(o, l);
  }
}

function parse_lines(_o, _ss) {
  while(true) {
    var ss = _ss;
    var o = _o;
    if (ss) {
      _ss = ss[1];
      _o = parse_line(o, ss[0]);
      continue ;
    } else {
      return o;
    }
  };
}

function parse(o, text) {
  var ss = $$String.split_on_char(/* "\n" */10, text);
  return parse_lines(o, ss);
}

var o = {
  state: /* FindX */0,
  line: /* [] */0,
  grid: /* [] */0,
  x: 0,
  y: 0
};

var r = parse_header(o, explode("x 1 y 123"));

Curry._2(Printf.printf(/* Format */[
          /* String_literal */Block.__(11, [
              "x = ",
              /* Int */Block.__(4, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* String_literal */Block.__(11, [
                      " y = ",
                      /* Int */Block.__(4, [
                          /* Int_d */0,
                          /* No_padding */0,
                          /* No_precision */0,
                          /* End_of_format */0
                        ])
                    ])
                ])
            ]),
          "x = %d y = %d"
        ]), r.x, r.y);

export {
  explode ,
  implode ,
  parse_int ,
  parse_header ,
  parse_map ,
  parse_line ,
  parse_lines ,
  parse ,
  o ,
  r ,
  
}
/* r Not a pure module */
